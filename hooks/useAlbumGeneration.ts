'use client'

import { useState, useCallback, useRef } from 'react'
import { clientFetch, createImageGenerationSSE } from '@/lib/api'
import { toast } from '@/lib/notifications'
import { resolvePreferences, type PreferencesState } from '@/components/ui/PreferencesPopover'
import type { TimelineEntry, GalleryImage } from '@/types'
import type { GeneratedImage, ImageSSEStatus } from '@/types/image-generation'

/**
 * Generation request configuration
 */
interface GenerationConfig {
    prompt: string
    inputImages: string[]
    preferences: PreferencesState
    albumId?: string
    isNewAlbum?: boolean // Explicitly indicate if this is a new album creation
}

/**
 * Callbacks for generation lifecycle
 */
interface GenerationCallbacks {
    onTimelineUpdate?: (entry: TimelineEntry) => void
    onGalleryUpdate?: (image: GalleryImage) => void
    onAlbumCreated?: (albumId: string, albumName: string) => void
    onGenerationStart?: (requestId: string) => void
    onGenerationComplete?: (images: GeneratedImage[]) => void
    onError?: (error: string) => void
    onGenerationError?: (requestId: string | null) => void
    onRequestIdReceived?: (requestId: string) => void
}

/**
 * Hook return type
 */
interface UseAlbumGenerationReturn {
    isGenerating: boolean
    generate: (config: GenerationConfig) => Promise<void>
    activeGenerations: Map<string, { numImages: number; aiEntryId: string }>
}

/**
 * useAlbumGeneration Hook
 * 
 * Unified generation flow using UUID-based routing for both new and existing albums.
 * 
 * **New Album Flow (UUID-based):**
 * 1. Parent generates UUID client-side and navigates to /albums/{uuid}
 * 2. Calls /api/image-gen/create with pre-generated album_id (UUID)
 * 3. Backend creates album with provided UUID + starts generation
 * 4. Returns album_name, request_id
 * 5. SSE connects after API response (album exists in backend)
 * 6. Triggers onAlbumCreated callback to update optimistic album name
 * 
 * **Existing Album Flow:**
 * 1. Adds optimistic placeholders to gallery
 * 2. Calls /api/image-gen/create with album_id
 * 3. Backend starts generation for existing album
 * 4. Returns request_id
 * 5. SSE connects after API response
 * 6. Updates placeholders when images complete
 * 
 * **Key Features:**
 * - UUID-based routing (no special 'new' route)
 * - Always requires album_id (pre-generated for new albums)
 * - SSE connects only after backend confirms album exists
 * - Real-time progress tracking
 * - Optimistic UI updates
 * - Supports multiple concurrent generations
 * 
 * @example
 * ```typescript
 * // NEW ALBUM - albumId is pre-generated UUID
 * const newAlbumId = crypto.randomUUID()
 * const { generate } = useAlbumGeneration({
 *   onAlbumCreated: (albumId, albumName) => {
 *     updateOptimisticAlbum(albumId, albumName) // Update sidebar
 *   }
 * })
 * await generate({
 *   prompt: "fashion editorial",
 *   inputImages: [],
 *   preferences: { count: 2, aspectRatio: '9:16' },
 *   albumId: newAlbumId // Pre-generated UUID
 * })
 * 
 * // EXISTING ALBUM - albumId from context
 * const { generate } = useAlbumGeneration({
 *   onGalleryUpdate: appendGalleryImage,
 * })
 * await generate({
 *   prompt: "fashion editorial",
 *   inputImages: [],
 *   preferences: { count: 2, aspectRatio: '9:16' },
 *   albumId: selectedAlbum.id // Existing album UUID
 * })
 * ```
 */
export function useAlbumGeneration(callbacks: GenerationCallbacks = {}): UseAlbumGenerationReturn {
    const [isGenerating, setIsGenerating] = useState(false)

    // Track active generations (for existing albums only)
    const activeGenerationsRef = useRef<Map<string, { numImages: number; aiEntryId: string }>>(
        new Map()
    )

    /**
     * Main generation function
     */
    const generate = useCallback(async (config: GenerationConfig) => {
        const { prompt, inputImages, preferences, albumId, isNewAlbum = false } = config

        // Validate input
        if (!prompt.trim() && inputImages.length === 0) {
            return
        }

        const resolvedPrefs = resolvePreferences(preferences)
        const numImages = resolvedPrefs.count

        setIsGenerating(true)

        // Track requestId for error cleanup
        let generationRequestId: string | null = null

        try {
            // === VALIDATION: Ensure album_id is always provided ===
            // For new albums: UUID pre-generated by parent
            // For existing albums: UUID from context

            // Track aiEntryId for existing albums (for placeholder mapping)
            let currentAiEntryId: string | null = null

            // === Add user timeline entry IMMEDIATELY for instant UX feedback ===
            // This shows the user's prompt and input images before waiting for API response
            const userTimelineEntryId = `user-${Date.now()}`
            const userEntry: TimelineEntry = {
                id: userTimelineEntryId,
                type: 'user',
                content: prompt,
                inputImages: inputImages, // Show uploaded images immediately
                prompt,
                status: 'complete',
                timestamp: new Date(),
            }
            callbacks.onTimelineUpdate?.(userEntry)

            // Add optimistic placeholders ONLY for existing albums
            // For new albums, placeholders added by parent component
            if (!isNewAlbum && albumId) {
                currentAiEntryId = (Date.now() + 1).toString()
                generationRequestId = currentAiEntryId // Track for error cleanup

                const placeholders: GalleryImage[] = Array.from({ length: numImages }, (_, i) => ({
                    id: `placeholder-${currentAiEntryId}-${i}`,
                    url: '',
                    name: '',
                    description: prompt,
                    status: 'rendering' as const,
                    addedAt: new Date(),
                    requestId: currentAiEntryId!, // Non-null since we're inside the if block
                    index: i,
                }))

                placeholders.forEach(placeholder => callbacks.onGalleryUpdate?.(placeholder))
                // Store with aiEntryId initially, will update with requestId once we get it
                activeGenerationsRef.current.set(currentAiEntryId, { aiEntryId: currentAiEntryId, numImages })
            }

            const endpoint = '/api/image-gen/create'

            // Validate album_id is always provided for new albums
            if (!albumId) {
                throw new Error('album_id is required')
            }

            // Build request body
            const requestBody: Record<string, any> = {
                prompt,
                input_images: inputImages.length > 0 ? inputImages : undefined,
                num_images: numImages,
                aspect_ratio: resolvedPrefs.aspectRatio,
                output_format: 'png',
                model: resolvedPrefs.model,
                album_id: albumId, // Always send UUID (pre-generated for new albums)
                new_album: isNewAlbum, // Flag to indicate if this is a new album creation
            }

            console.log('[useAlbumGeneration] Sending request:', {
                albumId,
                isNewAlbum,
                new_album: requestBody.new_album,
            });

            const response = await clientFetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
            })

            if (!response.ok) {
                const errorData = await response.json()
                throw new Error(errorData.error || 'Failed to generate images')
            }

            const responseData = await response.json()
            const data = responseData.data || responseData

            const requestId = data.request_id
            const albumName = data.album_name

            // === NEW ALBUM: Notify parent that album was created ===
            if (isNewAlbum && albumName) {
                // Album created successfully in backend
                // Parent component should refresh albums list
                callbacks.onAlbumCreated?.(albumId!, albumName)
            }

            // === Handle system message (both new and existing albums) ===
            if (data.system_message) {
                const systemEntry: TimelineEntry = {
                    id: data.timeline_event_id || `system-${Date.now()}`,
                    type: 'system',
                    content: data.system_message,
                    inputImages: [],
                    prompt: '',
                    status: 'complete',
                    timestamp: new Date(),
                    systemMessage: data.system_message,
                }
                callbacks.onTimelineUpdate?.(systemEntry)
            }

            // === Connect SSE for real-time updates (both new and existing albums) ===
            // SSE connects after successful API response (album exists in backend)
            if (data.request_id) {
                const requestId = data.request_id
                callbacks.onGenerationStart?.(requestId)

                // For new albums, notify parent to update placeholder requestIds
                if (isNewAlbum) {
                    callbacks.onRequestIdReceived?.(requestId)
                }

                // Get generation info using aiEntryId (from placeholder creation for existing albums)
                let generationInfo = currentAiEntryId ? activeGenerationsRef.current.get(currentAiEntryId) : null

                // For new albums, create generation info now
                if (!generationInfo && isNewAlbum) {
                    generationInfo = { aiEntryId: requestId, numImages }
                }

                // Update map to use requestId as key for future lookups
                if (generationInfo && currentAiEntryId) {
                    activeGenerationsRef.current.delete(currentAiEntryId)
                    activeGenerationsRef.current.set(requestId, generationInfo)
                } else if (generationInfo) {
                    activeGenerationsRef.current.set(requestId, generationInfo)
                }

                // Establish SSE connection (both new and existing albums)
                const eventSource = createImageGenerationSSE(requestId)

                eventSource.onmessage = (event) => {
                    try {
                        const sseData: ImageSSEStatus = JSON.parse(event.data)

                        if (sseData.status === 'complete') {
                            const images: GeneratedImage[] = sseData.images || []

                            // Update placeholders with actual images
                            if (generationInfo) {
                                images.forEach((img, index) => {
                                    const placeholderId = `placeholder-${generationInfo.aiEntryId}-${index}`
                                    callbacks.onGalleryUpdate?.({
                                        id: placeholderId,
                                        url: img.url,
                                        name: '',
                                        description: prompt,
                                        status: 'complete',
                                        addedAt: new Date(),
                                        requestId,
                                    })
                                })
                            }

                            eventSource.close()
                            activeGenerationsRef.current.delete(requestId)

                        } else if (sseData.status === 'error') {
                            console.error('[useAlbumGeneration] SSE error:', sseData.message)
                            eventSource.close()
                            activeGenerationsRef.current.delete(requestId)
                        }
                    } catch (parseError) {
                        console.error('[useAlbumGeneration] SSE parse error:', parseError)
                    }
                }

                eventSource.onerror = () => {
                    console.error('[useAlbumGeneration] SSE connection error')
                    eventSource.close()
                }
            }

        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : 'Unknown error'

            // Add error to timeline with user-friendly message
            const errorEntry: TimelineEntry = {
                id: `error-${Date.now()}`,
                type: 'error',
                content: 'Sorry, something went wrong',
                inputImages: inputImages, // Store input images for retry
                prompt: prompt, // Store original prompt for retry
                status: 'complete',
                timestamp: new Date(),
                errorMessage: 'Sorry, something went wrong',
            }
            callbacks.onTimelineUpdate?.(errorEntry)
            callbacks.onError?.(errorMsg)
            callbacks.onGenerationError?.(generationRequestId) // Trigger placeholder cleanup

            // Note: Toast notification removed - error shown in timeline with retry button
        } finally {
            setIsGenerating(false)
        }
    }, [callbacks])

    return {
        isGenerating,
        generate,
        activeGenerations: activeGenerationsRef.current,
    }
}
